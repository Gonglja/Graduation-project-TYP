C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DEMO
OBJECT MODULE PLACED IN demo.OBJ
COMPILER INVOKED BY: D:\1\Keil\C51\BIN\C51.EXE demo.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <intrins.h>
   2          #include <reg52.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          
   6          sbit LCD_RS=P1^2;//¶¨ÒåÒı½Å
   7          sbit LCD_RW=P1^1;
   8          sbit LCD_E=P1^0;
   9          //sbit PSB =P3^6;               //PSB½ÅÎª12864-12ÏµÁĞµÄ´®¡¢²¢Í¨Ñ¶¹¦ÄÜÇĞ»»£¬ÎÒÃÇÊ¹ÓÃ8Î»²¢ĞĞ½Ó¿Ú£¬PSB=1
  10          #define LCD_Data P2
  11          
  12          
  13          
  14          #define Busy    0x80 //ÓÃÓÚ¼ì²âLCD×´Ì¬×ÖÖĞµÄBusy±êÊ¶
  15          void WriteDataLCD(unsigned char WDLCD);
  16          void WriteCommandLCD(unsigned char WCLCD,BuysC);
  17          unsigned char ReadDataLCD(void);
  18          unsigned char ReadStatusLCD(void);
  19          void LCDInit(void);
  20          void LCDClear(void);
  21          void LCDFlash(void);
  22          void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData);
  23          void DisplayListChar(unsigned char X, unsigned char Y, unsigned char code *DData);
  24          //void DisplayImage (unsigned char code *DData);
  25          void Delay5Ms(void);
  26          void Delay400Ms(void);
  27          
  28          /////////////////////////´®¿Ú²¿·Ö///////////////
  29          uchar Uart_flag=0,recData=0;
  30          
  31          void UartInit(void);
  32          void Txd_Data(char Data);
  33          void PutString(unsigned char *TXStr); 
  34          //------------------´®¿ÚÍ¨ĞÅĞ­Òé-----------------//
  35          /*
  36            ¿Í»§¶ËÊı¾İ°ü¸ñÊ½½âÊÍ(³¤¶ÈºãÎª8):
  37            ÀıÈç:A1_T225#           Éè±¸1µÄÎÂ¶ÈÊÇ22.5
  38            A               -----Êı¾İ°üµÄ¿ªÊ¼±ê¼Ç(¿ÉÒÔÎªAµ½Z,ÒâÎ¶×ÅÊı¾İ°ü¿ÉÒÔÓĞ26ÖÖ)
  39            1                   -----Éè±¸´úºÅ
  40            T225        --------Ö¸Áî(³¤¶ÈºãÎª4)£¬Ö¸ÁîµÄÇ°1¸öÈË×Ö·ûÊÇÖ¸ÁîÍ·²¿£¬Ö¸ÁîµÄºó3¸ö×Ö·ûÊÇÖ¸ÁîÎ²²¿
  41            #           ---------Êı¾İ°üµÄ½áÊø±ê¼Ç
  42          
  43            ·şÎñÆ÷¶ËÊı¾İ°ü¸ñÊ½½âÊÍ(³¤¶ÈºãÎª15):
  44            ÀıÈç:A2_SenT010250#
  45            A--------Êı¾İ°üµÄ¿ªÊ¼±ê¼Ç(¿ÉÒÔÎªAµ½Z,ÒâÎ¶×ÅÊı¾İ°ü¿ÉÒÔÓĞ26ÖÖ)
  46            02-----Éè±¸´úºÅ
  47            SenT010250--------Ö¸Áî(³¤¶ÈºãÎª10)£¬Ö¸ÁîµÄÇ°4¸öÈË×Ö·ûÊÇÖ¸ÁîÍ·²¿£¬Ö¸ÁîµÄºó6¸ö×Ö·ûÊÇÖ¸ÁîÎ²²¿
  48            #---------Êı¾İ°üµÄ½áÊø±ê¼Ç
  49          */
  50          #define DataPacketLength 13
  51          uchar buf_string[DataPacketLength];  //¶¨ÒåÊı¾İ°ü³¤¶ÈÎª8¸ö×Ö·û
  52          #define deviceID '0'        //ÓÃÓÚ´®¿ÚÍ¨ĞÅÊ±£¬¶¨Òå±¾µØÉè±¸IDµÄµÚ1Î»
  53          #define datapackage_headflag 'A' //ÓÃÓÚ´®¿ÚÍ¨ĞÅÊ±£¬¶¨ÒåÊı¾İ°üÍ·²¿µÄÑéÖ¤±ê¼Ç
  54          
  55          uchar DataPackage[DataPacketLength]={datapackage_headflag,deviceID,'_','T','X','X','X','H','X','X','S','X'
C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 2   

             -,'#'};
  56          
  57          uchar slave1_temp_disp[4]={'T','X','X','X'};
  58          uchar slave2_temp_disp[4]={'T','X','X','X'};
  59          uchar slave1_hum_disp[3]={'H','X','X'};
  60          uchar slave2_hum_disp[3]={'H','X','X'};
  61          uchar slave1_s_disp[2]={'S','X'};
  62          uchar slave2_s_disp[2]={'S','X'};
  63          
  64          uchar code disp1[]={"Î»ÖÃ01µÄ¼à¿ØÈçÏÂ"};
  65          
  66          /////////////////////////////////////////////////////////////////////////////////////////////
  67          
  68          void main(void)
  69          {
  70   1              Delay400Ms(); //Æô¶¯µÈ´ı£¬µÈLCD½²Èë¹¤×÷×´Ì¬
  71   1              LCDInit(); //LCM³õÊ¼»¯
  72   1              Delay5Ms(); //ÑÓÊ±Æ¬¿Ì(¿É²»Òª)
  73   1              UartInit();
  74   1              while(1)
  75   1              {
  76   2                      //LCDClear();
  77   2                      //DisplayImage(tmp);//ÏÔÊ¾Í¼ĞÎ
  78   2                      //Delay400Ms();
  79   2                      //Delay400Ms();
  80   2                      //Delay400Ms();
  81   2                      //Delay400Ms();
  82   2                      //Delay400Ms();
  83   2                      //LCDClear();
  84   2                      //DisplayListChar(0,1,uctech);  //ÏÔÊ¾×Ö¿âÖĞµÄÖĞÎÄÊı×Ö
  85   2                      //DisplayListChar(0,2,net);             //ÏÔÊ¾×Ö¿âÖĞµÄÖĞÎÄÊı×Ö
  86   2                      //DisplayListChar(0,3,temp_disp);               //ÏÔÊ¾×Ö¿âÖĞµÄÖĞÎÄ
  87   2                      //DisplayListChar(0,4,qqDisplayListChar(0,4,qq);                //ÏÔÊ¾×Ö¿âÖĞµÄÖĞÎÄÊı×Ö
  88   2                      //Delay400Ms();
  89   2                      //Delay400Ms();
  90   2                      //Delay400Ms();
  91   2                      //Delay400Ms();
  92   2                      //LCDFlash();   //ÉÁË¸Ğ§¹û
  93   2                      //}
  94   2                      DisplayListChar(0,0,disp1);
  95   2                      DisplayOneChar(0,2,slave1_temp_disp[0]);
  96   2                      DisplayOneChar(1,2,slave1_temp_disp[1]);
  97   2                      DisplayOneChar(2,2,slave1_temp_disp[2]);
  98   2                      DisplayOneChar(3,2,slave1_temp_disp[3]);
  99   2                      DisplayOneChar(4,2,slave1_hum_disp[0]);
 100   2                      DisplayOneChar(5,2,slave1_hum_disp[1]);
 101   2                      DisplayOneChar(6,2,slave1_s_disp[0]);
 102   2                      DisplayOneChar(7,2,slave1_s_disp[1]);
 103   2      
 104   2                      DisplayOneChar(0,3,slave2_temp_disp[0]);
 105   2                      DisplayOneChar(1,3,slave2_temp_disp[1]);
 106   2                      DisplayOneChar(2,3,slave2_temp_disp[2]);
 107   2                      DisplayOneChar(3,3,slave2_temp_disp[3]);
 108   2                      //Delay400Ms();
 109   2                      //Delay400Ms();
 110   2                      //Delay400Ms();
 111   2                      //Delay400Ms();
 112   2                      //PutString(DataPackage);//¿Õ¸ñ20H,»Ø³µ0DH
 113   2                      
 114   2              }
 115   1      }
 116          
C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 3   

 117          //Ğ´Êı¾İ
 118          void WriteDataLCD(unsigned char WDLCD)
 119          {
 120   1              ReadStatusLCD(); //¼ì²âÃ¦ 
 121   1              LCD_RS = 1;
 122   1              LCD_RW = 0;
 123   1              LCD_Data = WDLCD;
 124   1              LCD_E = 1;
 125   1              LCD_E = 1;
 126   1              LCD_E = 1;
 127   1              LCD_E = 0;
 128   1      }
 129          
 130          //Ğ´Ö¸Áî
 131          void WriteCommandLCD(unsigned char WCLCD,BuysC) //BuysCÎª0Ê±ºöÂÔÃ¦¼ì²â
 132          {
 133   1              if (BuysC) ReadStatusLCD(); //¸ù¾İĞèÒª¼ì²âÃ¦ 
 134   1              LCD_RS = 0;
 135   1              LCD_RW = 0; 
 136   1              LCD_Data = WCLCD;
 137   1              LCD_E = 1; 
 138   1              LCD_E = 1;
 139   1              LCD_E = 1;
 140   1              LCD_E = 0;  
 141   1      }
 142          
 143          //¶ÁÊı¾İ
 144          unsigned char ReadDataLCD(void)
 145          {
 146   1              LCD_RS = 1; 
 147   1              LCD_RW = 1;
 148   1              LCD_E = 0;
 149   1              LCD_E = 0;
 150   1              LCD_E = 1;
 151   1              return(LCD_Data);
 152   1      }
 153          
 154          //¶Á×´Ì¬
 155          unsigned char ReadStatusLCD(void)
 156          {
 157   1              LCD_Data = 0xFF; 
 158   1              LCD_RS = 0;
 159   1              LCD_RW = 1; 
 160   1              LCD_E = 1;
 161   1              while (LCD_Data & Busy); //¼ì²âÃ¦ĞÅºÅ
 162   1              LCD_E = 0;
 163   1              return(LCD_Data);
 164   1      }
 165          
 166          void LCDInit(void) //LCM³õÊ¼»¯
 167          {
 168   1              WriteCommandLCD(0x30,1); //ÏÔÊ¾Ä£Ê½ÉèÖÃ,¿ªÊ¼ÒªÇóÃ¿´Î¼ì²âÃ¦ĞÅºÅ
 169   1              WriteCommandLCD(0x01,1); //ÏÔÊ¾ÇåÆÁ
 170   1              WriteCommandLCD(0x06,1); // ÏÔÊ¾¹â±êÒÆ¶¯ÉèÖÃ
 171   1              WriteCommandLCD(0x0C,1); // ÏÔÊ¾¿ª¼°¹â±êÉèÖÃ
 172   1      }
 173          void LCDClear(void) //ÇåÆÁ
 174          {
 175   1              WriteCommandLCD(0x01,1); //ÏÔÊ¾ÇåÆÁ
 176   1              WriteCommandLCD(0x34,1); // ÏÔÊ¾¹â±êÒÆ¶¯ÉèÖÃ
 177   1              WriteCommandLCD(0x30,1); // ÏÔÊ¾¿ª¼°¹â±êÉèÖÃ
 178   1      }
C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 4   

 179          void LCDFlash(void)     //ÉÁË¸Ğ§¹û
 180          {
 181   1              WriteCommandLCD(0x08,1); //ÏÔÊ¾ÇåÆÁ
 182   1              Delay400Ms();
 183   1              WriteCommandLCD(0x0c,1); // ÏÔÊ¾¿ª¼°¹â±êÉèÖÃ
 184   1              Delay400Ms();
 185   1              WriteCommandLCD(0x08,1); //ÏÔÊ¾ÇåÆÁ
 186   1              Delay400Ms();
 187   1              WriteCommandLCD(0x0c,1); // ÏÔÊ¾¿ª¼°¹â±êÉèÖÃ
 188   1              Delay400Ms();
 189   1              WriteCommandLCD(0x08,1); //ÏÔÊ¾ÇåÆÁ
 190   1              Delay400Ms();
 191   1      }
 192          //°´Ö¸¶¨Î»ÖÃÏÔÊ¾Ò»¸ö×Ö·û
 193          void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)
 194          {
 195   1              if(Y<1)
 196   1                Y=1;
 197   1              if(Y>4)
 198   1                Y=4;
 199   1                X &= 0x0F; //ÏŞÖÆX²»ÄÜ´óÓÚ16£¬Y²»ÄÜ´óÓÚ1
 200   1              switch(Y){
 201   2              case 1:X|=0X80;break;
 202   2              case 2:X|=0X90;break;
 203   2              case 3:X|=0X88;break;
 204   2              case 4:X|=0X98;break;
 205   2              }
 206   1              WriteCommandLCD(X, 0); //ÕâÀï²»¼ì²âÃ¦ĞÅºÅ£¬·¢ËÍµØÖ·Âë
 207   1              WriteDataLCD(DData);
 208   1      }
 209          
 210          //°´Ö¸¶¨Î»ÖÃÏÔÊ¾Ò»´®×Ö·û
 211          void DisplayListChar(unsigned char X, unsigned char Y, unsigned char code *DData)
 212          {
 213   1          unsigned char ListLength,X2;
 214   1          ListLength = 0;
 215   1          X2=X;
 216   1          if(Y<1)
 217   1                 Y=1;
 218   1          if(Y>4)
 219   1                 Y=4;
 220   1          X &= 0x0F; //ÏŞÖÆX²»ÄÜ´óÓÚ16£¬YÔÚ1-4Ö®ÄÚ
 221   1          switch(Y){
 222   2                      case 1:X2|=0X80;break;  //¸ù¾İĞĞÊıÀ´Ñ¡ÔñÏàÓ¦µØÖ·
 223   2                      case 2:X2|=0X90;break;
 224   2                      case 3:X2|=0X88;break;
 225   2                      case 4:X2|=0X98;break;
 226   2              }
 227   1        WriteCommandLCD(X2, 1); //·¢ËÍµØÖ·Âë
 228   1        while (DData[ListLength]>=0x20) //Èôµ½´ï×Ö´®Î²ÔòÍË³ö
 229   1        {
 230   2           if (X <= 0x0F) //X×ø±êÓ¦Ğ¡ÓÚ0xF
 231   2           {
 232   3                      WriteDataLCD(DData[ListLength]); //
 233   3                      ListLength++;
 234   3                      X++;
 235   3                      Delay5Ms();
 236   3          }
 237   2        }
 238   1      }
 239          
 240          //Í¼ĞÎÏÔÊ¾122*32
C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 5   

 241          //void DisplayImage (unsigned char code *DData){
 242          //      unsigned char x,y,i;
 243          //      unsigned int tmp=0;
 244          //      for(i=0;i<9;){          //·ÖÁ½ÆÁ£¬ÉÏ°ëÆÁºÍÏÂ°ëÆÁ£¬ÒòÎªÆğÊ¼µØÖ·²»Í¬£¬ĞèÒª·Ö¿ª
 245          //      for(x=0;x<32;x++){                              //32ĞĞ
 246          //              WriteCommandLCD(0x34,1);
 247          //              WriteCommandLCD((0x80+x),1);//ÁĞµØÖ·
 248          //              WriteCommandLCD((0x80+i),1);    //ĞĞµØÖ·£¬ÏÂ°ëÆÁ£¬¼´µÚÈıĞĞµØÖ·0X88
 249          //              WriteCommandLCD(0x30,1);                
 250          //              for(y=0;y<16;y++)       
 251          //                      WriteDataLCD(DData[tmp+y]);//¶ÁÈ¡Êı¾İĞ´ÈëLCD
 252          //              tmp+=16;                
 253          //      }
 254          //      i+=8;
 255          //      }
 256          //      WriteCommandLCD(0x36,1);        //À©³ä¹¦ÄÜÉè¶¨
 257          //      WriteCommandLCD(0x30,1);
 258          //}
 259          
 260          //5msÑÓÊ±
 261          void Delay5Ms(void)
 262          {
 263   1       unsigned int TempCyc = 5552;
 264   1       while(TempCyc--);
 265   1      }
 266          
 267          //400msÑÓÊ±
 268          void Delay400Ms(void)
 269          {
 270   1       unsigned char TempCycA = 5;
 271   1       unsigned int TempCycB;
 272   1       while(TempCycA--)
 273   1       {
 274   2        TempCycB=7269;
 275   2        while(TempCycB--);
 276   2       };
 277   1      }
 278          
 279          void UartInit()
 280          {
 281   1              SCON=0x50;   //´®¿Ú·½Ê½1£¬Ê¹ÄÜ½ÓÊÕ
 282   1              TMOD=0x20;  //¶¨Ê±Æ÷1¹¤×÷·½Ê½2£¨8Î»×Ô¶¯ÖØ×°³õÖµ£©
 283   1              
 284   1              TH1=0xfa;    //¼ÆÊıÆ÷³õÊ¼ÖµÉèÖÃ 9600bps
 285   1              TL1=0xfa;  
 286   1              PCON|=0x80;  //¶¨ÒåPCON¼Ä´æÆ÷ÖĞµÄSMOD=1,²¨ÌØÂÊ¼Ó±¶
 287   1              
 288   1              TR1=1;
 289   1              TI=0;
 290   1              RI=0;
 291   1              //PS=1;   //Ìá¸ß´®¿ÚÖĞ¶ÏÓÅÏÈ¼¶
 292   1              ES=1;  //¿ªÆô´®¿ÚÖĞ¶ÏÊ¹ÄÜ
 293   1              EA=1;
 294   1      }
 295          //
 296          //void Txd_Data(char Data)    //´®¿Ú·¢ËÍÊı¾İ
 297          //{
 298          //      SBUF = Data;
 299          //      while(!TI);
 300          //      TI=0;
 301          //}
 302          
C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 6   

 303          //´®¿Ú·¢ËÍº¯Êı
 304          void PutString(unsigned char *TXStr)  
 305          {                
 306   1          ES=0;     
 307   1          while(*TXStr!=0) 
 308   1          {                      
 309   2              SBUF=*TXStr;
 310   2              while(TI==0);
 311   2              TI=0;    
 312   2              TXStr++;
 313   2          }
 314   1          ES=1; 
 315   1      }                                                     
 316          //´®¿Ú½ÓÊÕº¯Êı
 317          bit ReceiveString()    
 318          {
 319   1          char * RecStr=buf_string;
 320   1          char num=0;
 321   1          unsigned char count=0;
 322   1          loop:    
 323   1                  *RecStr=SBUF;
 324   1                  count=0;
 325   1                  RI=0;    
 326   1                  if(num < DataPacketLength -1)  //Êı¾İ°ü³¤¶ÈÎª8¸ö×Ö·û,³¢ÊÔÁ¬Ğø½ÓÊÕ8¸ö×Ö·û
 327   1                  {
 328   2                      num++;
 329   2                      RecStr++;    
 330   2                      while(!RI)
 331   2                      {
 332   3                          count++;
 333   3                          if(count>130)return 0;    //½ÓÊÕÊı¾İµÈ´ıÑÓ³Ù£¬µÈ´ıÊ±¼äÌ«¾Ã»áµ¼ÖÂCPUÔËËãÏĞÖÃ£¬Ì«¶Ì»á³öÏÖ"Êı¾İ°
             -ü±»·Ö¸î",Ä¬ÈÏcount=130
 334   3                      }
 335   2                      goto loop;
 336   2                  }
 337   1          return 1;
 338   1      }
 339          ////±È½ÏÖ¸ÁîÍ·²¿
 340          //bit CompareCMD_head(char CMD_head[])    
 341          //{
 342          //     unsigned char CharNum;
 343          //     for(CharNum=0;CharNum<1;CharNum++)  //Ö¸Áî³¤¶ÈÎª8¸ö×Ö·û
 344          //     {
 345          //         if(!(buf_string[CharNum+3]==CMD_head[CharNum]))
 346          //         {
 347          //             return 0;  //Ö¸ÁîÍ·²¿Æ¥ÅäÊ§°Ü
 348          //         }
 349          //     }
 350          //     return 1;        //Ö¸ÁîÍ·²¿Æ¥Åä³É¹¦
 351          //}
 352          ////±È½ÏÖ¸ÁîÎ²²¿(start:´ÓÄÄÀï¿ªÊ¼±È½Ï£¬quality:±È½Ï¶àÉÙ¸ö×Ö·û£¬CMD_tail[]£ºÒª±È½ÏµÄ×Ö·û´®)
 353          //bit CompareCMD_tail(unsigned char start,unsigned char quality,char CMD_tail[]) 
 354          //{
 355          //     unsigned char CharNum;
 356          //     for(CharNum=0;CharNum<quality;CharNum++)
 357          //     {
 358          //         if(!(buf_string[start+CharNum]==CMD_tail[CharNum]))
 359          //         {
 360          //             return 0; 
 361          //         }
 362          //     }
 363          //     return 1;
C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 7   

 364          // }
 365          
 366          bit Deal_UART_RecData()   //´¦Àí´®¿Ú½ÓÊÕÊı¾İ°üº¯Êı£¨³É¹¦´¦ÀíÊı¾İ°üÔò·µ»Ø1£¬·ñÔò·µ»Ø0£©
 367           {
 368   1           //PutString(buf_string);
 369   1           if(buf_string[0]==datapackage_headflag&&buf_string[DataPacketLength -1]=='#')  //½øĞĞÊı¾İ°üÍ·Î²±ê¼ÇÑé
             -Ö¤
 370   1           {        
 371   2               switch(buf_string[1])        //Ê¶±ğ·¢ËÍÕßÉè±¸IDµÄµÚ1Î»Êı×Ö
 372   2               {
 373   3                   case '1':
 374   3                       switch(buf_string[2])        //Ê¶±ğ·¢ËÍÕßÉè±¸IDµÄµÚ2Î»Êı×Ö
 375   3                       {
 376   4                           case '_':
 377   4                               if(buf_string[3]=='T')    //ÅĞ¶ÏÖ¸ÁîÍ·²¿ÊÇ·ñÎª'T'
 378   4                               {
 379   5                                       //temp =  buf_string[4]*100+buf_string[5]*10+buf_string[6]; 
 380   5                                      slave1_temp_disp[1]=buf_string[4];
 381   5                                                              slave1_temp_disp[2]=buf_string[5];
 382   5                                                              slave1_temp_disp[3]=buf_string[6];
 383   5                                                       }
 384   4                               if(buf_string[7]=='H')  
 385   4                               {
 386   5                                   slave1_hum_disp[1]= buf_string[8]; 
 387   5                                                               slave1_hum_disp[2]= buf_string[9];           
 388   5                                   
 389   5                               }
 390   4                               if(buf_string[10]=='S')  
 391   4                               {
 392   5                                   slave1_s_disp[1]= buf_string[11]; 
 393   5                                   
 394   5                               }
 395   4                               return 0;
 396   4                           
 397   4                           default:
 398   4                               return 0;
 399   4                       }
 400   3      
 401   3                               case '2':
 402   3                       switch(buf_string[2])        //Ê¶±ğ·¢ËÍÕßÉè±¸IDµÄµÚ2Î»Êı×Ö
 403   3                       {
 404   4                           case '_':
 405   4                               if(buf_string[3]=='T')    //ÅĞ¶ÏÖ¸ÁîÍ·²¿ÊÇ·ñÎª'T'
 406   4                               {
 407   5                                       //temp =  buf_string[4]*100+buf_string[5]*10+buf_string[6]; 
 408   5                                      slave2_temp_disp[1]=buf_string[4];
 409   5                                                              slave2_temp_disp[2]=buf_string[5];
 410   5                                                              slave2_temp_disp[3]=buf_string[6];
 411   5                                                       }
 412   4                               if(buf_string[3]=='H')  
 413   4                               {
 414   5                                               
 415   5                                   
 416   5                               }
 417   4                               if(buf_string[3]=='Q')  
 418   4                               {
 419   5                                   
 420   5                                   
 421   5                               }
 422   4                               if(buf_string[3]=='W')  
 423   4                               {
 424   5                                   
C51 COMPILER V9.00   DEMO                                                                  03/12/2019 18:48:39 PAGE 8   

 425   5                                   
 426   5                               }
 427   4                               return 0;
 428   4                           
 429   4                           default:
 430   4                               return 0;
 431   4                       }
 432   3                   default:
 433   3                       return 0;
 434   3               }
 435   2           }
 436   1           return 0;
 437   1       }
 438          void ser() interrupt 4          //´®¿ÚÖĞ¶Ï
 439          {
 440   1              if(ReceiveString())    
 441   1          {
 442   2              //Êı¾İ°ü³¤¶ÈÕıÈ·ÔòÖ´ĞĞÒÔÏÂ´úÂë
 443   2              Deal_UART_RecData();   
 444   2          }
 445   1          else
 446   1          {
 447   2              //Êı¾İ°ü³¤¶È´íÎóÔòÖ´ĞĞÒÔÏÂ´úÂë
 448   2              //LED1=~LED1;                
 449   2          }
 450   1          RI=0;  //½ÓÊÕ²¢´¦ÀíÒ»´ÎÊı¾İºó°Ñ½ÓÊÕÖĞ¶Ï±êÖ¾Çå³ıÒ»ÏÂ£¬¾Ü¾øÏìÓ¦ÔÚÖĞ¶Ï½ÓÊÕÃ¦µÄÊ±ºò·¢À´µÄÇëÇó
 451   1      }
 452          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    773    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     46       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
